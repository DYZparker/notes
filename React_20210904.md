# 

# nanoid库

生成唯一id

# ...扩展运算符

- 在数组中正常使用

- 在对象中表示复制

  ```html
  var a = {x: 1, y: 2}
  var b = {...a}		//复制了a
  var c = {...a, y: 3}		//复制了a，并且修改了y的值
  ```

  

# 连续解构赋值

```html
let obj = {a: {b: {c: 1}}}
let {a: {b: {c}}} = obj		//解构出c 
let {a: {b: {c: d}}} = obj		//解构出c的同时把c重命名为d
```



# 关于类式组件中调用函数为什么要bind(this)?

1. A组件是一个继承类，其中的F函数是放在A的原型对象上的

2. 类中的方法默认开启了局部的严格模式，所以F函数中的this是undefined

3. 解决办法：

   ```js
   constructor(props){
       super(props)
       //初始化状态
       this.state = {isHot:false,wind:'微风'}
       //解决changeWeather中this指向问题
       this.changeWeather = this.changeWeather.bind(this)
   }
   ```

   ```this.changeWeather = this.changeWeather.bind(this)```是一个赋值语句，右边的this.changeWeather是A组件原型链上的方法，用bind改变this指向并返回一个新函数赋值给A组件，所以A组件就有了自己的changeWeather方法，在A组件的函数中调用this.changeWeather就不会是undefined了

4. 是





# 一、React基础

## 1. React简介

**1.1. 官网**

- 英文官网:[ https://reactjs.org/](https://reactjs.org/)

- 中文官网: https://react.docschina.org/

**1.2. 介绍描述**

- 用于动态构建用户界面的 JavaScript 库(只关注于视图)

- 由Facebook开源

**1.3. React的特点**

- 声明式编码

- 组件化编码

- React Native 编写原生应用

- 高效（优秀的Diffing算法）

**1.4. React高效的原因**

- 使用虚拟(virtual)DOM, 不总是直接操作页面真实DOM。

- DOM Diffing算法, 最小化页面重绘。

## 2. React的基本使用                        

### 2.1. 相关js库

```jsx
<script type="text/javascript" src="../js/react.development.js"></script>
<script type="text/javascript" src="../js/react-dom.development.js"></script>
<script type="text/javascript" src="../js/babel.min.js"></script>
```

- react.js：React核心库。

- react-dom.js：提供操作DOM的react扩展库。

- babel.min.js：解析JSX语法代码转为JS代码的库。

### 2.2. 创建虚拟DOM的两种方式

- 纯JS方式(一般不用)

  ```jsx
  <script type="text/javascript" > 
      //1.创建虚拟DOM
      const VDOM = React.createElement('h1',{id:'title'},React.createElement('span',{},'Hello,React'))
      //2.渲染虚拟DOM到页面
      ReactDOM.render(VDOM,document.getElementById('test'))
  </script>
  ```

- JSX方式

  ```jsx
  <script type="text/babel" > /* 此处一定要写babel */
      //1.创建虚拟DOM
      const VDOM = (  /* 此处一定不要写引号，因为不是字符串 */
      <h1 id="title">
          <span>Hello,React</span>
      </h1>
      )
      //2.渲染虚拟DOM到页面
      ReactDOM.render(VDOM,document.getElementById('test'))
  </script>
  ```

### 2.3. 虚拟DOM与真实DOM

- React提供了一些API来创建一种 “特别” 的一般js对象

  ```jsx
  const VDOM = React.createElement('xx',{id:'xx'},'xx')
  ```

- 虚拟DOM对象最终都会被React转换为真实的DOM

- 我们编码时基本只需要操作react的虚拟DOM相关数据, react会转换为真实DOM变化而更新界。

## 3. React JSX

### 3.1. JSX

- 全称: JavaScript XML

- react定义的一种类似于XML的JS扩展语法: 
  - JS + XML本质是```React.createElement(component, props, ...children)```方法的语法糖

- 作用: 用来简化创建虚拟DOM 
  - 写法：```var ele = <h1>Hello JSX!</h1>```
  - 注意1：它不是字符串, 也不是HTML/XML标签
  - 注意2：它最终产生的就是一个JS对象

- 标签名任意: HTML标签或其它标签

- 标签属性任意: HTML标签属性或其它

- 基本语法规则
  - 遇到 <开头的代码, 以标签的语法解析: html同名标签转换为html同名元素, 其它标签需要特别解析
  - 遇到以 { 开头的代码，以JS语法解析: 标签中的js表达式必须用{ }包含
  - 样式的类名指定不要用class，要用className
  - 内联样式，要用style={{key:value}}的形式去写

- babel.js的作用
  - 浏览器不能直接解析JSX代码, 需要babel转译为纯JS的代码才能运行
  - 只要用了JSX，都要加上type="text/babel", 声明需要babel来处理

### 3.2. 渲染虚拟DOM(元素)

- 语法: ```ReactDOM.render(virtualDOM,containerDOM)```

- 作用: 将虚拟DOM元素渲染到页面中的真实容器DOM中显示

- 参数说明
  - 参数一: 纯js或jsx创建的虚拟dom对象
  - 参数二: 用来包含虚拟DOM元素的真实dom元素对象(一般是一个div)

## 4. 模块与组件、模块化与组件化

**4.1. 模块**

- 理解：向外提供特定功能的js程序, 一般就是一个js文件

- 为什么要拆成模块：随着业务逻辑增加，代码越来越多且复杂。

- 作用：复用js, 简化js的编写, 提高js运行效率

**4.2. 组件**

- 理解：用来实现局部功能效果的代码和资源的集合(html/css/js/image等等)

- 为什么要用组件： 一个界面的功能更复杂

- 作用：复用编码, 简化项目编码, 提高运行效率

**4.3. 模块化**

当应用的js都以模块来编写的, 这个应用就是一个模块化的应用

**4.4. 组件化**

当应用是以多组件的方式实现, 这个应用就是一个组件化的应用

 

# 二、组件

## 1. 组件分类

**1.1 函数式组件**

```jsx
function MyComponent(){
    console.log(this); //此处的this是undefined，因为babel编译后开启了严格模式
    return <h2>我是用函数定义的组件(适用于【简单组件】的定义)</h2>
}
```

- 执行了```ReactDOM.render(<MyComponent/>.......```之后，发生了什么？
  - React解析组件标签，找到了MyComponent组件。
  - 发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中。

**1.2 类式组件**

```jsx
class MyComponent extends React.Component {
    render(){
        //render是放在哪里的？—— MyComponent的原型对象上，供实例使用。
        //render中的this是谁？—— MyComponent的实例对象 <=> MyComponent组件实例对象。
        console.log('render中的this:',this);
        return <h2>我是用类定义的组件(适用于【复杂组件】的定义)</h2>
    }
}
```

- 执行了```ReactDOM.render(<MyComponent/>.......```之后，发生了什么？
  - React解析组件标签，找到了MyComponent组件。
  - 发现组件是使用类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法。
  - 将render返回的虚拟DOM转为真实DOM，随后呈现在页面中。

## 2. 组件三大核心属性

### 2.1 state

#### 2.1.1. 定义

- 常规写法（有constructor）

  ```jsx
  class Weather extends React.Component{
      constructor(props){
          super(props)
          //初始化状态
          this.state = {isHot:false,wind:'微风'}
          //解决changeWeather中this指向问题
          this.changeWeather = this.changeWeather.bind(this)
      }
      render(){
          const {isHot,wind} = this.state
          return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' : '凉爽'}，{wind}</h1>
      }
      changeWeather(){
          //changeWeather放在哪里？ ———— Weather的原型对象上，供实例使用
          //由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用
          //类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined
          //获取原来的isHot值
          const isHot = this.state.isHot
          //严重注意：状态必须通过setState进行更新,且更新是一种合并，不是替换。
          this.setState({isHot:!isHot})
          //严重注意：状态(state)不可直接更改，下面这行就是直接更改！！！
          //this.state.isHot = !isHot //这是错误的写法
      }
  }
  ```

- 精简写法（无constructor）

  ```jsx
  class Weather extends React.Component{
      state = {isHot:false,wind:'微风'}
      render(){
          const {isHot,wind} = this.state
          return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' : '凉爽'}，{wind}</h1>
      }
      //自定义方法————要用赋值语句的形式+箭头函数
      changeWeather = ()=>{
          const isHot = this.state.isHot
          this.setState({isHot:!isHot})
      }
  }
  ```

#### 2.1.2. 理解

- state是组件对象最重要的属性, 值是对象(可以包含多个key-value的组合)

- 组件被称为"状态机", 通过更新组件的state来更新对应的页面显示(重新渲染组件)

#### 2.1.3. 注意

- 组件中render方法中的this为组件实例对象

- 组件自定义的方法中this为undefined，如何解决？
  - 强制绑定this: 通过函数对象的bind()
  - 箭头函数

- 状态数据，不能直接修改或更新

### 2.2 props

#### 2.2.1. 理解

- 每个组件对象都会有props(properties的简写)属性

- 组件标签的所有属性都保存在props中

#### 2.2.2. 作用

- 通过标签属性从组件外向组件内传递变化的数据

- 注意: 组件内部不要修改props数据

#### 2.2.3. 对props进行约束

- 类式组件props约束

  - 常规版

  ```jsx
  <!-- 引入prop-types，用于对组件标签属性进行限制 -->
  <script type="text/javascript" src="../js/prop-types.js"></script>
  
  class Person extends React.Component{
      render(){
          const {name,age,sex} = this.props
          //props是只读的
          //this.props.name = 'jack' //此行代码会报错，因为props是只读的
          return (
              <ul>
                  <li>姓名：{name}</li>
                  <li>性别：{sex}</li>
                  <li>年龄：{age+1}</li>
              </ul>
          )
      }
  }
  //对标签属性进行类型、必要性的限制
  Person.propTypes = {
      name:PropTypes.string.isRequired, //限制name必传，且为字符串
      sex:PropTypes.string,//限制sex为字符串
      age:PropTypes.number,//限制age为数值
      speak:PropTypes.func,//限制speak为函数
  }
  //指定默认标签属性值
  Person.defaultProps = {
      sex:'男',//sex默认值为男
      age:18 //age默认值为18
  }
  ```

  - 精简版

  ```jsx
  <!-- 引入prop-types，用于对组件标签属性进行限制 -->
  <script type="text/javascript" src="../js/prop-types.js"></script>
  
  class Person extends React.Component{
      constructor(props){
          //构造器是否接收props，是否传递给super，取决于：是否希望在构造器中通过this访问props
          super(props)
      }
      //对标签属性进行类型、必要性的限制
      static propTypes = {
          name:PropTypes.string.isRequired, //限制name必传，且为字符串
          sex:PropTypes.string,//限制sex为字符串
          age:PropTypes.number,//限制age为数值
      }
      //指定默认标签属性值
      static defaultProps = {
          sex:'男',//sex默认值为男
          age:18 //age默认值为18
      }
      render(){
          const {name,age,sex} = this.props
          return (
              <ul>
                  <li>姓名：{name}</li>
                  <li>性别：{sex}</li>
                  <li>年龄：{age+1}</li>
              </ul>
          )
      }
  }
  ```

- 函数式组件props约束

  ```jsx
  function Person (props){
      const {name,age,sex} = props
      return (
          <ul>
              <li>姓名：{name}</li>
              <li>性别：{sex}</li>
              <li>年龄：{age}</li>
          </ul>
      )
  }
  Person.propTypes = {
      name:PropTypes.string.isRequired, //限制name必传，且为字符串
      sex:PropTypes.string,//限制sex为字符串
      age:PropTypes.number,//限制age为数值
  }
  
  Person.defaultProps = {
      sex:'男',//sex默认值为男
      age:18 //age默认值为18
  }
  ```

### 2.3 refs与事件处理

#### 2.3.1. 理解

组件内的标签可以定义ref属性来标识自己

#### 2.3.2. 编码

- 字符串形式的ref

  ```jsx
  class Demo extends React.Component{
      showData = ()=>{
          const {input1} = this.refs
          alert(input1.value)
      }
      render(){
          return(
              <div>
                  <input ref="input1" type="text" placeholder="点击按钮提示数据"/>&nbsp;
                  <button onClick={this.showData}>点我提示左侧的数据</button>&nbsp;
              </div>
          )
      }
  }
  ```

  

- 回调形式的ref

  ```jsx
  class Demo extends React.Component{
      showData = ()=>{
          const {input1} = this
          alert(input1.value)
      }
      render(){
          return(
              <div>
                  {//如果回调函数是以内联函数的方式定义，在更新过程中它会执行两次且第一次传入的参数是null，所以最好将函数写到class中}
                  <input ref={c => this.input1 = c } type="text" placeholder="点击按钮提示数据"/>&nbsp;
                  <button onClick={this.showData}>点我提示左侧的数据</button>&nbsp;
              </div>
          )
      }
  }
  ```

  

- createRef创建ref容器·

  ```jsx
  class Demo extends React.Component{
  	//React.createRef调用后可以返回一个容器，该容器可以存储被ref所标识的节点,该容器是“专人专用”的
      myRef = React.createRef()
      myRef2 = React.createRef()
      //展示左侧输入框的数据
      showData = ()=>{
          alert(this.myRef.current.value);
      }
      //展示右侧输入框的数据
      showData2 = ()=>{
          alert(this.myRef2.current.value);
      }
      render(){
          return(
              <div>
                  <input ref={this.myRef} type="text" placeholder="点击按钮提示数据"/>&nbsp;
                  <button onClick={this.showData}>点我提示左侧的数据</button>&nbsp;
                  <input onBlur={this.showData2} ref={this.myRef2} type="text" placeholder="失去焦点提示数据"/>&nbsp;
              </div>
          )
      }
  }
  ```
  
  

#### 2.3.3. 事件处理

- 通过onXxx属性指定事件处理函数(注意大小写)
  - React使用的是自定义(合成)事件, 而不是使用的原生DOM事件
  - React中的事件是通过事件委托方式处理的(委托给组件最外层的元素)

- 通过event.target得到发生事件的DOM元素对象

## 3. 组件的生命周期

### 3.1. 理解

- 组件从创建到死亡它会经历一些特定的阶段。
- React组件中包含一系列勾子函数(生命周期回调函数), 会在特定的时刻调用。
-  我们在定义组件时，会在特定的生命周期回调函数中，做特定的工作。
-  触发事件的回调函数必须是一个函数，而不能在函数后加()，会表示把函数的调用结果赋给事件
- 如果要给回调函数传参有两种方法
  - 利用高阶函数（参数为函数或返回函数）+函数的柯里化（参数依次传入包裹的函数并将结果一次返回）
  - 直接在事件的回调函数外包裹一个箭头函数，并且此箭头函数的参数event事件也可作为回调函数的参数传递

### 3.2. 生命周期流程图(旧)

 ![react生命周期(旧)](E:\Study\Notes\image\react生命周期(旧).png)

- **初始化阶段:** 由ReactDOM.render()触发---初次渲染

  (1).   constructor()

  (2).   componentWillMount()

  (3).   render()

  (4).   componentDidMount()

- **更新阶段:** 由组件内部this.setSate()或父组件重新render触发

  (1).   shouldComponentUpdate()

  (2).   componentWillUpdate()

  (3).   render()

  (4).   componentDidUpdate()

- **卸载组件:** 由ReactDOM.unmountComponentAtNode()触发

  (1).   componentWillUnmount()

### 3.3. 生命周期流程图(新)

![react生命周期(新)](E:\Study\Notes\image\react生命周期(新).png)

- **初始化阶段:** 由ReactDOM.render()触发---初次渲染

  (1).   constructor()

  (2).   getDerivedStateFromProps

  (3).   render()

  (4).   componentDidMount()

- **更新阶段:** 由组件内部this.setSate()或父组件重新render触发

  (1).   getDerivedStateFromProps

  (2).   shouldComponentUpdate()

  (3).   render()

  (4).   getSnapshotBeforeUpdate

  (5).   componentDidUpdate()

- **卸载组件:** 由ReactDOM.unmountComponentAtNode()触发

  (1).   componentWillUnmount()

### 3.4. 重要的勾子

- render：初始化渲染或更新渲染调用

- componentDidMount：开启监听, 发送ajax请求

- componentWillUnmount：做一些收尾工作, 如: 清理定时器

### 3.5. 即将废弃的勾子

- componentWillMount

- componentWillReceiveProps

- componentWillUpdate

> 现在使用会出现警告，下一个大版本需要加上UNSAFE_前缀才能使用，以后可能会被彻底废弃，不建议使用。

## 4. 组件中的key

**4.1 虚拟DOM中key的作用：**

- 简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。

- 详细的说: 
  - 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】, 
  - 随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：
  - 旧虚拟DOM中找到了与新虚拟DOM相同的key：
    - 若虚拟DOM中内容没变, 直接使用之前的真实DOM
    - 若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM
  - 旧虚拟DOM中未找到与新虚拟DOM相同的key
    - 根据数据创建新的真实DOM，随后渲染到到页面          

**4.2 用index作为key可能会引发的问题：**

- 若对数据进行：逆序添加、逆序删除等破坏顺序操作:
  - 会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低。

- 如果结构中还包含输入类的DOM：
  - 会产生错误DOM更新 ==> 界面有问题。

- 注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，
  - 仅用于渲染列表用于展示，使用index作为key是没有问题的。

**4.3 开发中如何选择key?:**

- 最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。

- 如果确定只是简单的展示数据，用index也是可以的。

## 5. 收集表单数据

### 5.1. 非受控组件

```jsx
class Login extends React.Component{
    handleSubmit = (event)=>{
        event.preventDefault() //阻止表单提交
        const {username,password} = this
        alert(`你输入的用户名是：${username.value},你输入的密码是：${password.value}`)
    }
    render(){
        return(
            <form onSubmit={this.handleSubmit}>
                用户名：<input ref={c => this.username = c} type="text" name="username"/>
                密码：<input ref={c => this.password = c} type="password" name="password"/>
                <button>登录</button>
            </form>
        )
    }
}
```



### 5.2. 受控组件

```jsx
class Login extends React.Component{
    //初始化状态
    state = {
        username:'', //用户名
        password:'' //密码
    }
    //保存用户名到状态中
    saveUsername = (event)=>{
        this.setState({username:event.target.value})
    }
    //保存密码到状态中
    savePassword = (event)=>{
        this.setState({password:event.target.value})
    }
    //表单提交的回调
    handleSubmit = (event)=>{
        event.preventDefault() //阻止表单提交
        const {username,password} = this.state
        alert(`你输入的用户名是：${username},你输入的密码是：${password}`)
    }
    render(){
        return(
            <form onSubmit={this.handleSubmit}>
                用户名：<input onChange={this.saveUsername} type="text" name="username"/>
                密码：<input onChange={this.savePassword} type="password" name="password"/>
                <button>登录</button>
            </form>
        )
    }
}
```



# 三、React应用

## 1. react脚手架

- xxx脚手架: 用来帮助程序员快速创建一个基于xxx库的模板项目
  - 包含了所有需要的配置（语法检查、jsx编译、devServer…）
  - 下载好了所有相关的依赖
  - 可以直接运行一个简单效果

- react提供了一个用于创建react项目的脚手架库: create-react-app

- 项目的整体技术架构为: react + webpack + es6 + eslint

- 使用脚手架开发的项目的特点: 模块化, 组件化, 工程化

## 2. 创建项目并启动

**第一步**，全局安装：npm i -g create-react-app

**第二步**，切换到想创项目的目录，使用命令：create-react-app hello-react

**第三步**，进入项目文件夹：cd hello-react

**第四步**，启动项目：npm start

## 3. react脚手架项目结构

 public ---- 静态资源文件夹

​            favicon.icon ------ 网站页签图标

​            **index.html --------** **主页面**

​            logo192.png ------- logo图

​            logo512.png ------- logo图

​            manifest.json ----- 应用加壳的配置文件

​            robots.txt -------- 爬虫协议文件

src ---- 源码文件夹

​            App.css -------- App组件的样式

​            **App.js --------- App组件**

​            App.test.js ---- 用于给App做测试

​            index.css ------ 样式

​            **index.js -------** **入口文件**

​            logo.svg ------- logo图

​            reportWebVitals.js

​                    --- 页面性能分析文件(需要web-vitals库的支持)

​            setupTests.js

​                    ---- 组件单元测试的文件(需要jest-dom库的支持)

## 4. 功能界面的组件化编码流程

- 拆分组件: 拆分界面,抽取组件

- 实现静态组件: 使用组件实现静态页面效果

- 实现动态组件
  - 动态显示初始化数据
    - 数据类型
    - 数据名称
    - 保存在哪个组件?
  - 交互(从绑定事件监听开始)

## 5. UI组件库

- material-ui(国外)
  - 官网: http://www.material-ui.com/#/
  - github: https://github.com/callemall/material-ui

- ant-design(国内蚂蚁金服)
  - 官网: https://ant.design/index-cn

  - Github: https://github.com/ant-design/ant-design/

  - **antd的按需引入+自定主题**

    - 安装依赖：yarn add react-app-rewired customize-cra babel-plugin-import less less-loader

    - 修改package.json

      ```jsx
      "scripts": {
          "start": "react-app-rewired start",
          "build": "react-app-rewired build",
          "test": "react-app-rewired test",
          "eject": "react-scripts eject"
      }
      ```

    - 根目录下创建config-overrides.js

      ```jsx
      //配置具体的修改规则
      const { override, fixBabelImports,addLessLoader} = require('customize-cra');
      module.exports = override(
          fixBabelImports('import', {
              libraryName: 'antd',
              libraryDirectory: 'es',
              style: true,
          }),
          addLessLoader({
              lessOptions:{
                  javascriptEnabled: true,
                  modifyVars: { '@primary-color': 'green' },
              }
          }),
      );
      ```

    - 备注：不用在组件里亲自引入样式了，即：import 'antd/dist/antd.css'应该删掉

# 四、React ajax

## 1. 理解

### 1.1. 前置说明

- React本身只关注于界面, 并不包含发送ajax请求的代码

- 前端应用需要通过ajax请求与后台进行交互(json数据)

- react应用中需要集成第三方ajax库(或自己封装)

### 1.2. 常用的ajax请求库

- jQuery: 比较重, 如果需要另外引入不建议使用

- axios: 轻量级, 建议使用
  - 封装XmlHttpRequest对象的ajax
  - promise风格
  - 可以用在浏览器端和node服务器端

## 2. axios

### 2.1. 文档

https://github.com/axios/axios

### 2.2. 相关API

- GET请求

  ```jsx
  axios.get('/user?ID=12345')   
      .then(function (response) {    
      console.log(response.data);   
  }).catch(function (error) {
      console.log(error);
  });     
  
  axios.get('/user', {    
      params: {     
          ID: 12345    
      }   
  }).then(function (response) {  
      console.log(response); 
  }).catch(function (error) {  
      console.log(error);  
  });
  ```

  

- POST请求

  ```jsx
  axios.post('/user', {   
      firstName: 'Fred',  
      lastName: 'Flintstone' 
  }).then(function (response) { 
      console.log(response); 
  }).catch(function (error) { 
      console.log(error); 
  });
  ```

  

## 3. 消息订阅-发布机制

- 工具库: PubSubJS

- 下载: npm install pubsub-js --save

- 使用: 
  - import PubSub from 'pubsub-js' //引入
  - PubSub.subscribe('delete', function(data){ }); //订阅
  - PubSub.publish('delete', data) //发布消息

- 订阅组件（收数据）

  ```jsx
  import PubSub from 'pubsub-js'
  
  componentDidMount() {
  	this.token = PubSub.subscribe('消息名', (msg, data) => {
  		//处理接收来的data数据
  	})
  }
  componentWillUnmount() {
  	PubSub.unsubscribe(this.token)
  }
  ```

  

- 发布组件（传数据）

  ```jsx
  import PubSub from 'pubsub-js'
  
  PubSub.publish('消息名', {数据})
  ```

  

## 4. 扩展：Fetch

### 41. 文档

-  https://github.github.io/fetch/

- https://segmentfault.com/a/1190000003810652

### 4.2. 特点

- fetch: 原生函数，不再使用XmlHttpRequest对象提交ajax请求

- 老版本浏览器可能不支持

### 4.3. 相关API

- GET请求

  ```jsx
  fetch(url).then(function(response) {  
      return response.json()   
  }).then(function(data) {    
      console.log(data)   
  }).catch(function(e) {   
      console.log(e)   
  }); 
  ```

  

- POST请求

  ```jsx
  fetch(url, {   
      method: "POST",   
      body: JSON.stringify(data), 
  }).then(function(data) { 
      console.log(data)  
  }).catch(function(e) {  
      console.log(e) 
  })
  ```

  

# 五、React路由

## 1. 理解

### 1.1. SPA

- 单页Web应用（single page web application，SPA）。

- 整个应用只有**一个完整的页面**。

- 点击页面中的链接**不会刷新**页面，只会做页面的**局部更新。**

- 数据都需要通过ajax请求获取, 并在前端异步展现。

### 1.2. 路由

**1.2.1 什么是路由?**

- 一个路由就是一个映射关系(key:value)

- key为路径, value可能是function或component

**1.2.2 路由分类**

- 后端路由：
  - 理解： value是function, 用来处理客户端提交的请求。
  - 注册路由： router.get(path, function(req, res))
  - 工作过程：当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据

- 前端路由：
  - 浏览器端路由，value是component，用于展示页面内容。
  - 注册路由: <Route path="/test" component={Test}>
  - 工作过程：当浏览器的path变为/test时, 当前路由组件就会变为Test组件

**1.2.3** **路由的基本使用**

- 明确好界面中的导航区、展示区

- 导航区的a标签改为Link标签

  ``` <Link to="/xxxxx">Demo</Link>```

- 展示区写Route标签进行路径的匹配

  ```<Route path='/xxxx' component={Demo}/>```

- ```<App>```的最外侧包裹了一个```<BrowserRouter>```或```<HashRouter>```

## 2. react-router-dom

- react的一个插件库。

- 专门用来实现一个SPA应用。

- 基于react的项目基本都会用到此库。

### 2.1. 路由内置组件

- ```<BrowserRouter>```：history模式，包裹点击路由需要展现的组件

- ```<HashRouter>```：hash模式，包裹点击路由需要展现的组件

- ```<Route>```：需要路由展现的组件标签，exact属性可以精确匹配

- ```<Redirect>```：一般写在所有路由注册的最下方，当所有路由都无法匹配时，跳转到Redirect指定的路由

- ```<Link>```：路由点击标签

- ```<NavLink>```：可以实现路由链接的高亮，通过activeClassName指定样式名

- ```<Switch>```：包裹在所有路由外层，可以提高路由匹配效率(单一匹配)，匹配到后将不再继续往下匹配

### 2.2. 路由组件与一般组件的区别

路由组件的props多了history、location、match三个属性

- 写法不同：

​            一般组件：<Demo/>

​            路由组件：<Route path="/demo" component={Demo}/>

- 存放位置不同：

​            一般组件：components

​            路由组件：pages

- 接收到的props不同：

​            一般组件：写组件标签时传递了什么，就能收到什么

​            路由组件：接收到三个固定的属性

```jsx
history:
    go: ƒ go(n)
    goBack: ƒ goBack()
    goForward: ƒ goForward()
    push: ƒ push(path, state)
    replace: ƒ replace(path, state)
location:
    pathname: "/about"
    search: ""
    state: undefined
match:
    params: {}
    path: "/about"
    url: "/about"
```

### 2.3 给函数式组件添加history

```jsx
import { useHistory } from "react-router-dom"
const Fn = () => {
    let history = useHistory()
}
```



## 3. 嵌套路由

- 注册子路由时要写上父路由的path值

- 路由的匹配是按照注册路由的顺序进行的

## 4. 向路由组件传递参数数据

- params参数
  - 路由链接(携带参数)：<Link to='/demo/test/tom/18'}>详情</Link>
  - 注册路由(声明接收)：<Route path="/demo/test/:name/:age" component={Test}/>
  - 接收参数：this.props.match.params

- search参数
  - 路由链接(携带参数)：<Link to='/demo/test?name=tom&age=18'}>详情</Link>
  - 注册路由(无需声明，正常注册即可)：<Route path="/demo/test" component={Test}/>
  - 接收参数：this.props.location.search

  > 备注：获取到的search是urlencoded编码字符串，需要借助querystring解析
  >
  > ```js
  > import qs from querystring;
  > 
  > var myString = "name=Parker&age=26";
  > var myObj = qs.parse(myString);		//{name: Parker, age: 26}
  > ```

- state参数

​              路由链接(携带参数)：<Link to={{pathname:'/demo/test',state:{name:'tom',age:18}}}>详情</Link>

​              注册路由(无需声明，正常注册即可)：<Route path="/demo/test" component={Test}/>

​              接收参数：this.props.location.state

​              备注：刷新也可以保留住参数

## 5. withRouter

高阶组件中的withRouter, 作用是将一个组件包裹进Route里面, 然后react-router的三个对象history, location, match就会被放进这个组件的props属性中.

```js
import { NavLink, withRouter } from "react-router-dom"
class Nav extends React.Component{}
export default withRouter(Nav)
```



## 6. 多种路由跳转方式

### 6.1 ```<link>```标签

### 6.2 编程式路由导航

借助this.prosp.history对象上的API对操作路由跳转、前进、后退

- this.prosp.history.push()

- this.prosp.history.replace()

- this.prosp.history.goBack()

- this.prosp.history.goForward()

- this.prosp.history.go()

## 7 BrowserRouter与HashRouter的区别

- 底层原理不一样：
  - BrowserRouter使用的是H5的history API，不兼容IE9及以下版本。
  - HashRouter使用的是URL的哈希值。

- path表现形式不一样
  - BrowserRouter的路径中没有#,例如：localhost:3000/demo/test
  - HashRouter的路径包含#,例如：localhost:3000/#/demo/test

- 刷新后对路由state参数的影响
  - BrowserRouter没有任何影响，因为state保存在history对象中。
  - HashRouter刷新后会导致路由state参数的丢失！！！

- 备注：HashRouter可以用于解决一些路径错误相关的问题。

## 8. React Router 6

### 8.1 概述

- React Router以三个不同的包发布到npm上，它们分别为：
  - react-router：路由的核心库，提供了很多的：组件、钩子
  - react-router-dom：包含react-router所有内容，并添加一些专门用于DOM的组件，例如```<BrowserRouter>```等
  - react-router-native：包括react-router所有内容，并添加一些专门用于ReactNative的API，例如```<NativeRouter>```等
- 与React Router 5版本相比，改变了什么？
  - 内置组件的变化：移除```<Switch />```，新增```<Routes>```等
  - 语法的变化：```component = { About }```变为```element = { <About /> }```等
  - 新增多个hook：```useParams```、```useNavigate```、```useMatch```等
  - 官方明确推荐函数式组件了

### 8.2 Component

#### 8.2.1 ```<BrowserRouter>```

- 说明：用于包裹整个应用

- 示例代码：

  ```jsx
  import React from "react"
  import ReactDOM from "react-dom"
  import { BrowserRouter } from "react-router-dom"
  
  ReactDOM.render(
  	<BrowserRouter>
  		{/* 整体结构（通常为App组件） */}
  	</BrowserRouter>.root
  )
  ```

#### 8.2.1 ```<HashRouter>```

- 说明：作用与```<BrowserRouter>```一样，但```<HashRouter>```修改的是地址栏的hash值
- 备注：6版本中的```<BrowserRouter>```和```<HashRouter>```的用法与5相同

#### 8.2.2 ```<Routes />与<Route />```

- 6版本移除了先前的```<Switch>```，引入了新的替代者：```<Routes>```

- ```<Routes>```和```<Route>```要配合使用，且必须要用```<Routes>```包裹```<Route>```

- ```<Route>```相当于一个if语句，如果其路径与当前的URL匹配，则呈现其对应的组件

- ```<Route caseSensitive>```属性用于指定：匹配时是否区分大小写（默认为false）

- 当URL变化时，```<Routes>```都会查看其所有子```<Route>```元素以找到最佳匹配并呈现组件

- ```<Route>```也可以嵌套路由，且可配合```useRoutes()```配合“路由表”，但需要通过```<Outlet>```组件来渲染其子路由

- 示例代码：

  ```jsx
  <Routes>
  	/* path属性用于定义路径，element属性用于定义当前路径所对应的组件 */
  	<Route path="/login" element={<Login />}></Route>
  	
  	/* 用于定义嵌套路由，home是一级路由，对应的路径/home */
  	<Route path="/home" element={<Home />}>
          /* test1和test2是二级路由，对应的路径是/home/test1和/home/test2 */
      	<Route path="test1" element={<Test />}></Route>
          <Route path="test2" element={<Test2 />}></Route>
      </Route>
  	
  	/* Route也可以不写element属性，这时就是用于展示嵌套的路由，所对应的路径是/users/xxx */
  	<Route path="users"}>
          /* test1和test2是二级路由，对应的路径是/home/test1和/home/test2 */
      	<Route path="xxx" element={<Demo />}></Route>
      </Route>
  </Routes>
  ```

#### 8.2.3 ```<Link>```

- 作用：修改URL，且不发送网络请求（路由链接）

- 注意：外侧需要用```<BrowserRouter>```或```<HashRouter>```

- 示例代码：

  ```jsx
  import { Link } from "react-router-dom"
  
  function Test() {
      return (
      	<div>
          	<Link to="/路径">按钮</Link>
          </div>
      )
  }
  ```

#### 8.2.4 ```<NavLink>```

- 作用：与```<Link>```组件类似，且可实现导航的“高亮”效果

- 示例代码：

  ```jsx
  //注意：NavLink默认类名是active，下面是指定自定义的class
  
  //自定义样式
  <NavLink
      to="login"
      className={({isActive}) => {
          return isActive ? 'base one' : 'base'
      }}>
      login
  </NavLink>
  
  /*
  	默认情况下，当Home的子组件匹配成功，Home的导航也会高亮
  	当NavLink上添加了end属性后，若Home的子组件匹配成功，则Home的导航没有高亮效果
  */
  <NavLink to="home" end>home</NavLink>
  ```

  

#### 8.2.5 ```<Navigate>```

- 作用：只要```<Navigate>```组件被渲染，就会修改路径，切换视图

- ```replace```属性用于控制跳转模式（push或replace，默认是push）

- 示例代码：

  ```jsx
  import React,{useState} from 'react'
  imoprt {Navigate} from 'react-router-dom'
  
  export default function Home() {
      const [sum, setSum] = useState(1)
      return (
      	<div>
          	<h3>我是Home的内容</h3>
              {/* 根据sum的值决定是否切换视图 */}
              {sum === 1 ? <h4>sum的值为{sum}</h4>} : <Navigate to="/about" replace={true} />}
              <button onClick={() => setSum(2)}>点我将sum变为2</button>
          </div>
      )
  }
  ```

#### 8.2.6 ```<Outlet>```

- 当```<Route>```产生嵌套时，渲染其对应的后续子路由

- 示例代码：

  ```jsx
  //根据路由表生成对应的路由规则
  const element = useRoutes([
      {
          path: '/about',
          element: <About />
      },
      {
          path: '/home',
          element: <Home />,
          children:[
              {
                  path: 'news',
                  element: <News />
              },
              {
                  psth: 'message',
                  element: <Message />
              }
          ]
      }
  ])
  
  //Home.js
  import React from 'react'
  import {NavLink, Outlet} from 'react-router-dom'
  
  export default function Home() {
      
  }
  ```

### 8.3 Hooks

#### 8.3.1 useRoutes()

- 作用：根据路由表，动态创建```<Routes>```和```<Route>```

- 示例代码：

  ```jsx
  //路由表配置：src/routes/index.js
  import About from '../pages/About'
  import Home from '../pages/Home'
  import {Navigate} from 'react-router-dom'
  
  export default [
      {
          path: '/about',
          element: <About />
      },
      {
          path: '/home',
          element: <Home />
      },
      {
          path: '/',
          element: <Navigate to="/about" />
      }
  ]
  
  //App.js
  import React from 'react'
  import {NavLink, useRoutes} from 'react-router-dom'
  import routes from './routes'
  
  export default function App() {
      //根据路由表生成对应的路由规则
      const element = useRoutes(routes)
      return (
          
      )
  }
  ```

#### 8.3.2 useNavigate()

- 作用：返回一个函数用来实现编程式导航

- 示例代码：

  ```jsx
  import React from 'react'
  import {Navigate} from 'react-router-dom'
  
  export default function Demo() {
      const navigate = useNavigate()
      const handle = () => {
          //第一种使用方式：指定具体的路径
          navigate('/login', {
              replace: false,
              state: {a: 1, b: 2}
          })
          //第二种使用方式：传入数值进行前进或后退，类似于5版本中的history.go()方法
          navigate(-1)
      }
      return (
          <div>
          	<button onClick={handle}>按钮</button>
          </div>
      )
  }
  ```

#### 8.3.3 useParams()

- 作用：返回当前匹配路由的params参数，类似于5版本中的match.params

- 示例代码：

  ```jsx
  import React from 'react'
  import {Routes, Route, useParams} from 'react-router-dom'
  import User from './pages/User.jsx'
  
  function ProfilePage() {
      //获取URL中携带过来的params参数
      let { id } = useParams()
      const navigate = useNavigate()
  }
  
  function App() {
      return (
      	<Routes>
          	<Route path="users/:id" element={<user />} />
          </Routes>
      )
  }
  ```

  

#### 8.3.4 useSearchParams()

- 作用：用于读取和修改当前位置的URL中的查询字符串

- 返回一个包含两个值的数组，内容分别为：当前的search参数、更新search的函数

- 示例代码：

  ```jsx
  import React from 'react'
  import {useSearchParams} from 'react-router-dom'
  
  export default function Detail() {
      const [search, setSearch] = useSearchParams()
      const id = search.get('id')
      const title = search.get('title')
      const content = search.get('content')
      
      return (
      	<ul>
          	<li>
              	<button onClick={() => setSearch('id=008&title=哈哈&content=嘻嘻')}>点我更新一下收到的search参数</button>
              </li>
              <li>消息编号：{id}</li>
              <li>消息标题：{title}</li>
              <li>消息内容：{content}</li>
          </ul>
      )
  }
  ```

#### 8.3.5 useLocation()

- 作用：获取当前location信息，对标5版本中的路由组件的location属性

- 示例代码：

  ```jsx
  import React from 'react'
  import {useLocation} from 'react-router-dom'
  
  export default function Detail() {
      const x = useLocation()
      //x就是location对象
      /*
      	{
      		hash: "",
      		key: "ah9nv6sz",
      		pathname: "/login",
      		search: "?name=zs&age=18",
      		state: {a: 1, b: 2}
      	}
      */
      return (
      	<ul>
              <li>消息编号：{id}</li>
              <li>消息标题：{title}</li>
              <li>消息内容：{content}</li>
          </ul>
      )
  }
  ```

#### 8.3.6 useMatch()

- 作用：返回当前匹配信息，对标5版本中的路由组件的match属性

- 示例代码：

  ```jsx
  <Route path="/login/:page/:pageSize" element={<Login /> /}
  <NavLink to="/login/1/10">登录</NavLink>
  
  export default function Login() {
      const match = useMatch('/login/:x/:y')
      //match对象内容如下
      /*
      	{
      		params: {x: '1', y: '10'},
      		pathname: "/LoGin/1/10",
      		pathnameBase: "/loGin/1/10",
      		pattern: {
      			path: '/login/:x/:y',
      			caseSensitive: false,
      			end: false
      		}
      	}
      */
      return (
      	<ul>
              <h1>Login</h1>
          </ul>
      )
  }
  ```



#### 8.3.7 useRouterContext()

#### 8.3.8 useNavigationType()

#### 8.3.9 useOutlet()

#### 8.3.10 useResolvedPath()



# 六、redux

## 1. redux基础

**1.1. 学习文档**

- 英文文档: https://redux.js.org/

- 中文文档: http://www.redux.org.cn/

- Github: https://github.com/reactjs/redux

**1.2. redux是什么**

- redux是一个专门用于做**状态管理**的JS库(不是react插件库)。

- 它可以用在react, angular, vue等项目中, 但基本与react配合使用。

- 作用: 集中式管理react应用中多个组件**共享**的状态。

**1.3. 什么情况下需要使用redux**

- 某个组件的状态，需要让其他组件可以随时拿到（共享）。

- 一个组件需要改变另一个组件的状态（通信）。

- 总体原则：能不用就不用, 如果不用比较吃力才考虑使用。

**1.4. redux工作流程**

 ![redux原理图](E:\Study\Notes\image\redux原理图.png)

## 2. redux的三个核心概念

### 2.1. action

- 动作的对象

- 包含2个属性
  - type：标识属性, 值为字符串, 唯一, 必要属性
  - data：数据属性, 值类型任意, 可选属性

- 例子：```{ type: 'ADD_STUDENT',data:{name: 'tom',age:18} }```
- 可新建constant.js文件，专门存放type值防止写错，```export const ADD_PERSON = 'add_person'```

```jsx
import {ADD_PERSON} from '../constant'

//创建增加一个人的action动作对象
export const addPerson = personObj => ({type:ADD_PERSON,data:personObj})
```



### 2.2. reducer

- 用于初始化状态、加工状态。

- 加工时，根据旧的state和action， 产生新的state的纯函数。
- reducer的本质是一个函数，接收：preState,action，返回加工后的状态
- reducer被第一次调用时，是store自动触发的，

```jsx
import {ADD_PERSON} from '../constant'

//初始化人的列表
const initState = [{id:'001',name:'tom',age:18}]

export default function personReducer(preState=initState,action){
	const {type,data} = action
	switch (type) {
		case ADD_PERSON: //若是添加一个人
			//preState.unshift(data) //此处不可以这样写，这样会导致preState被改写了，personReducer就不是纯函数了。
			return [data,...preState]
		default:
			return preState
	}
}
```



### 2.3. store

- 将state、action、reducer联系在一起的对象

- 如何得到此对象?
  - ```import {createStore} from 'redux'```
  - ```import reducer from './reducers'```
  - ```const store = createStore(reducer)```

- 此对象的功能?
  - ```getState()```: 得到state
  - ```dispatch(action)```: 分发action, 触发reducer调用, 产生新的state
  - ```subscribe(listener)```: 注册监听, 当产生了新的state时, 自动调用

```jsx
//引入createStore，专门用于创建redux中最为核心的store对象
import {createStore} from 'redux'
//引入为Person组件服务的reducer
import personReducer from './person_reducer'
//暴露store
export default createStore(personReducer)
```



## 3. redux的核心API

### 3.1. createstore()

作用：创建包含指定reducer的store对象

### 3.2. store对象

- 作用: redux库最核心的管理对象

- 它内部维护着:
  - ```state```
  - ```reducer```

- 核心方法:
  - ```getState()```
  - ```dispatch(action)```
  - ```subscribe(listener)```

- 具体编码:
  - ```store.getState()```
  - ```store.dispatch({type:'INCREMENT', number})```
  - ```store.subscribe(render)```

### 3.3. applyMiddleware()

```jsx
//引入createStore，专门用于创建redux中最为核心的store对象
import {createStore,applyMiddleware} from 'redux'
//引入为Count组件服务的reducer
import countReducer from './count_reducer'
//引入redux-thunk，用于支持异步action
import thunk from 'redux-thunk'
//暴露store
export default createStore(countReducer,applyMiddleware(thunk))
```

作用：应用上基于redux的中间件(插件库)

### 3.4. combineReducers()

```jsx
//引入combineReducers，用于汇总多个reducer
import {combineReducers} from 'redux'
//引入为Count组件服务的reducer
import count from './count'
//引入为Person组件服务的reducer
import persons from './person'

//汇总所有的reducer变为一个总的reducer
export default  combineReducers({
	count,
	persons
})

```

作用：合并多个reducer函数

## 4. redux异步编程

### 4.1理解：

- redux默认是不能进行异步处理的,

- 某些时候应用中需要在redux中执行异步任务(ajax, 定时器)

### 4.2. 使用异步中间件

npm install --save redux-thunk

- 在reducer.js中

  ```jsx
  import {INCREMENT,DECREMENT} from '../constant'
  
  //同步action，就是指action的值为Object类型的一般对象
  export const increment = data => ({type:INCREMENT,data})
  export const decrement = data => ({type:DECREMENT,data})
  
  //异步action，就是指action的值为函数,异步action中一般都会调用同步action，异步action不是必须要用的。
  export const incrementAsync = (data,time) => {
  	return (dispatch)=>{
  		setTimeout(()=>{
  			dispatch(increment(data))
  		},time)
  	}
  }
  ```

  

- 在store.js中

  ```jsx
  //引入createStore，专门用于创建redux中最为核心的store对象
  import {createStore,applyMiddleware} from 'redux'
  //引入汇总之后的reducer
  import reducer from './reducers'
  //引入redux-thunk，用于支持异步action
  import thunk from 'redux-thunk'
  //引入redux-devtools-extension
  import {composeWithDevTools} from 'redux-devtools-extension'
  
  //暴露store 
  export default createStore(reducer,composeWithDevTools(applyMiddleware(thunk)))
  ```

  

## 5. react-redux

### 5.1. 理解

- 一个react插件库

- 专门用来简化react应用中使用redux

### 5.2. react-Redux将所有组件分成两大类

- UI组件
  - 只负责 UI 的呈现，不带有任何业务逻辑
  - 通过props接收数据(一般数据和函数)
  - 不使用任何 Redux 的 API
  - 一般保存在components文件夹下

- 容器组件
  - 负责管理数据和业务逻辑，不负责UI的呈现
  - 使用 Redux 的 API
  - 一般保存在containers文件夹下

### 5.3. 相关API

- Provider：让所有组件都可以得到state数据

  ```jsx
  //在App的index.js中
  import {Provider} from 'react-redux'
  
  ReactDOM.render(
  	/* 此处需要用Provider包裹App，目的是让App所有的后代容器组件都能接收到store */
  	<Provider store={store}>
  		<App/>
  	</Provider>,
  	document.getElementById('root')
  )
  ```

  

- mapStateToprops：将外部的数据（即state对象）转换为UI组件的标签属性

  ```jsx
  //在UI组件中
  const mapStateToProps = (state) => {
  	return {count:state}
  }
  ```

  

- mapDispatchToProps：将分发action的函数转换为UI组件的标签属性

  ```jsx
  //在UI组件中
  const mapDispatchToProps = (dispatch) => {
  	return {
  		increment:number => dispatch(createIncrementAction(number)),
  		decrement:number => dispatch(createDecrementAction(number)),
  		increment:(number,time) => dispatch(createIncrementAsyncAction(number,time)),
  	}
  }
  ```

  

- connect：用于包装 UI 组件生成容器组件

  ```jsx
  //在UI组件中
  export default connect(mapStateToProps,mapDispatchToProps)(CountUI)
  ```

  

- mapStateToprops、mapDispatchToProps和connect的合并写法

  ```jsx
  //使用connect()()创建并暴露一个Count的容器组件
  export default connect(
  	state => ({
  		count:state.count,
  		personCount:state.persons.length
  	}),
  	{increment,decrement,incrementAsync}
  )(Count)
  ```

  

## 6. 使用上redux调试工具

### 6.1. 安装chrome浏览器插件

### 6.2. 下载工具依赖包

```npm install --save-dev redux-devtools-extension```

```jsx
//在redux的store.js中
//引入createStore，专门用于创建redux中最为核心的store对象
import {createStore,applyMiddleware} from 'redux'
//引入汇总之后的reducer
import reducer from './reducers'
//引入redux-thunk，用于支持异步action
import thunk from 'redux-thunk'
//引入redux-devtools-extension
import {composeWithDevTools} from 'redux-devtools-extension'

//暴露store 
export default createStore(reducer,composeWithDevTools(applyMiddleware(thunk)))
```

## 7. 纯函数和高阶函数

### 7.1. 纯函数

- 一类特别的函数: 只要是同样的输入(实参)，必定得到同样的输出(返回)

- 必须遵守以下一些约束 
  - 不得改写参数数据
  - 不会产生任何副作用，例如网络请求，输入和输出设备
  - 不能调用Date.now()或者Math.random()等不纯的方法 

- redux的reducer函数必须是一个纯函数

### 7.2. 高阶函数

- 理解: 一类特别的函数
  - 情况1: 参数是函数
  - 情况2: 返回是函数

- 常见的高阶函数: 
  - 定时器设置函数
  - 数组的forEach()/map()/filter()/reduce()/find()/bind()
  - promise
  - react-redux中的connect函数

- 作用: 能实现更加动态, 更加可扩展的功能



# 七、Hooks

## 1. React Hook/Hooks是什么?

- Hook是React 16.8.0版本增加的新特性/新语法
- 可以让你在函数组件中使用 state 以及其他的 React 特性

## 2. Hook使用规则

- 只能在**函数最外层**调用 Hook。不要在循环、条件判断或者子函数中调用。
- 只能在 **React 的函数组件**中调用 Hook。不要在其他 JavaScript 函数中调用

## 3. useState

- State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作

- 语法: const [xxx, setXxx] = React.useState(initValue)  

- useState()说明:
  - 参数: 第一次初始化指定的值在内部作缓存
  - 返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数

- setXxx()2种写法:
  - setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值
  - setXxx(value => newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值

## 4. useEffect

- Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)

- React中的副作用操作:

  - 发ajax请求数据获取

  - 设置订阅 / 启动定时器

  - 手动更改真实DOM

- 语法和说明: 

  ```jsx
  useEffect(() => { 
      // 在此可以执行任何带副作用操作
      return () => { // 在组件卸载前执行
          // 在此做一些收尾工作, 比如清除定时器/取消订阅等
      }
  }, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行
  ```

  

- 可以把 useEffect Hook 看做如下三个函数的组合
  - componentDidMount()
  - componentDidUpdate()
  - componentWillUnmount() 

## 5. useContext

- 接收一个 context 对象（`React.createContext` 的返回值）并返回该 context 的当前值。
- 当前的 context 值由上层组件中距离当前组件最近的 `<MyContext.Provider>` 的 `value` prop 决定。
- 当组件上层最近的 `<MyContext.Provider>` 更新时，该 Hook 会触发重渲染，并使用最新传递给 `MyContext` provider 的 context `value` 值。
- 即使祖先使用 [`React.memo`](https://react.docschina.org/docs/react-api.html#reactmemo) 或 [`shouldComponentUpdate`](https://react.docschina.org/docs/react-component.html#shouldcomponentupdate)，也会在组件本身使用 `useContext` 时重新渲染。
- 调用了 `useContext` 的组件总会在 context 值变化时重新渲染。

## 6. useRef

- Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据

- 语法: ```const refContainer = useRef(initialValue);```

- `useRef` 返回一个可变的 ref 对象，其 `.current` 属性被初始化为传入的参数（`initialValue`）。

- 返回的 ref 对象在组件的整个生命周期内保持不变。

- 作用:保存标签对象,功能与React.createRef()一样

  ```jsx
  function TextInputWithFocusButton() {
    const inputEl = useRef(null);
    const onButtonClick = () => {
      // `current` 指向已挂载到 DOM 上的文本输入元素
      inputEl.current.focus();
    };
    return (
      <>
        <input ref={inputEl} type="text" />
        <button onClick={onButtonClick}>Focus the input</button>
      </>
    );
  }
  ```

- 当 ref 对象内容发生变化时，`useRef` 并*不会*通知你。变更 `.current` 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref来实现。

## 7. useReducer

- useState的替代方案

  ```jsx
  const reducer = (state, action) => newState;
  const [state, dispatch] = useReducer(reducer, initialArg, init);
  ```

- 适用于 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。

- 使用 `useReducer` 还能给那些会触发深更新的组件做性能优化，因为可以向子组件传递 `dispatch` 而不是回调函数。

## 8. useCallback

- 返回一个memoized函数

  ```jsx
  const memoizedCallback = useCallback(
    () => {
      doSomething(a, b);
    },
    [a, b],
  );
  ```

  

- ```useCallback(fn, deps)``` 相当于 ```useMemo(() => fn, deps)```

## 9. useMemo

- 返回一个memoized值

- 传入 `useMemo` 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作。

- 如果没有提供依赖项数组，`useMemo` 在每次渲染时都会计算新的值。

- useMemo与useEffect区别

  |          | useEffect          | useMemo                    | useCallback                         |
  | -------- | ------------------ | -------------------------- | ----------------------------------- |
  | 执行时机 | reder之后          | reder期间                  | reder期间                           |
  | 依赖数组 | 数组变更执行副作用 | 数组值变更才重新计算       | 数组值变更才重新调用函数/渲染子组件 |
  | 主要用途 | 生命周期执行副作用 | 类似不需重复计算的计算属性 | 包裹不需更新的子组件                |

  

## 10. 自定义Hook

- 自定义 Hook 更像是一种约定而不是功能。如果函数的名字以 “`use`” 开头并调用其他 Hook，我们就说这是一个自定义 Hook。
- Hook 的每次*调用*都有一个完全独立的 state ， 因此你可以在单个组件中多次调用同一个自定义 Hook。



# 八、补充

## 1. setState

### 1.1 setState更新状态的2种写法

- setState(stateChange, [callback])------对象式的setState
  - stateChange为状态改变对象(该对象可以体现出状态的更改)
  - callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用
- setState(updater, [callback])------函数式的setState
  - updater为返回stateChange对象的函数。
  - updater可以接收到state和props。
  - callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。

### 1.2 总结:

- 对象式的setState是函数式的setState的简写方式(语法糖)
- 使用原则：
  - 如果新状态不依赖于原状态 ===> 使用对象方式
  - 如果新状态依赖于原状态 ===> 使用函数方式
  - 如果需要在setState()执行后获取最新的状态数据, 要在第二个callback函数中读取



## 2. key

​      1). react/vue中的key有什么作用？（key的内部原理是什么？）
​      2). 为什么遍历列表时，key最好不要用index?
​      

      1. 虚拟DOM中key的作用：
          1). 简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。
    
          2). 详细的说: 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】, 
                        随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：
    
          ​        a. 旧虚拟DOM中找到了与新虚拟DOM相同的key：
          ​              (1).若虚拟DOM中内容没变, 直接使用之前的真实DOM
          ​              (2).若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM
    
          ​        b. 旧虚拟DOM中未找到与新虚拟DOM相同的key
          ​              根据数据创建新的真实DOM，随后渲染到到页面
          ​        
    
      2. 用index作为key可能会引发的问题：
            1). 若对数据进行：逆序添加、逆序删除等破坏顺序操作:
            会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低。
    
            2). 如果结构中还包含输入类的DOM：
            会产生错误DOM更新 ==> 界面有问题。
    
            3). 注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，
            于渲染列表用于展示，使用index作为key是没有问题的。


​            

      3. 开发中如何选择key?:
            1). 最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。
            2). 如果确定只是简单的展示数据，用index也是可以的。



## 3. lazyLoad

### 路由组件的lazyLoad

```jsx
//1.通过React的lazy函数配合import()函数动态加载路由组件 ===> 路由组件代码会被分开打包
const Login = lazy(()=>import('@/pages/Login'))

//2.通过<Suspense>指定在加载得到路由打包文件前显示一个自定义loading界面
<Suspense fallback={<h1>loading.....</h1>}>	//如果loading是需要引入的组件就用一般引入，不要用懒加载
    <Switch>
        <Route path="/xxx" component={Xxxx}/>
    	<Redirect to="/login"/>
    </Switch>
</Suspense>
```



## 4. Fragment

### 使用

	<Fragment><Fragment>
	<></>

### 作用

> 可以不用必须有一个真实的DOM根标签了



<hr/>

## 5. Context

### 理解

> 一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信

### 使用

5.1 创建Context容器对象

```jsx
const XxxContext = React.createContext()
```

  	

5.2 渲染子组时，外面包裹xxxContext.Provider, 通过value属性给后代组件传递数据：	

```jsx
<xxxContext.Provider value={数据}>		
    子组件    
</xxxContext.Provider>
```

​    

5.3 后代组件读取数据

- 第一种方式:仅适用于类组件

```jsx
static contextType = xxxContext  // 声明接收context	  
this.context // 读取context中的value数据	  
```



- 第二种方式: 函数组件与类组件都可以

```jsx
<xxxContext.Consumer>	    
    {	      
        value => ( // value就是context中的value数据	        
        	要显示的内容	      
        )	    
    }	  
</xxxContext.Consumer>
```



### 注意

	在应用开发中一般不用context, 一般都用它的封装react插件



<hr/>


## 6. 组件优化

### Component的2个问题 

> 1. 只要执行setState(),即使不改变状态数据, 组件也会重新render() ==> 效率低
>
> 2. 只当前组件重新render(), 就会自动重新render子组件，纵使子组件没有用到父组件的任何数据 ==> 效率低

### 效率高的做法

>  只有当组件的state或props数据发生改变时才重新render()

### 原因

>  Component中的shouldComponentUpdate()总是返回true

### 解决

	办法1:
	重写shouldComponentUpdate()方法	比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false
	办法2:
	使用PureComponent	PureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true
	注意:
	只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false
	不要直接修改state数据, 而是要产生新数据项目中一般使用PureComponent来优化



<hr/>


## 7. render props

### 如何向组件内部动态传入带内容的结构(标签)?

	Vue中:
	使用slot技术, 也就是通过组件标签体传入结构  <A><B/></A>
	React中:
	使用children props: 通过组件标签体传入结构
	使用render props: 通过组件标签属性传入结构,而且可以携带数据，一般用render函数属性

### children props

```jsx
<A>
	<B>xxxx</B>
</A>
{this.props.children}问题: 如果B组件需要A组件内的数据, ==> 做不到 
```

### render props

```jsx
<A render={(data) => <C data={data}></C>}></A>
A组件: {this.props.render(内部state数据)}
C组件: 读取A组件传入的数据显示 {this.props.data} 
```



<hr/>

## 8. 错误边界

#### 理解：

错误边界(Error boundary)：用来捕获后代组件错误，渲染出备用页面

#### 特点：

只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误

##### 使用方式：

getDerivedStateFromError配合componentDidCatch

```js
// 生命周期函数，一旦后台组件报错，就会触发
static getDerivedStateFromError(error) {
    console.log(error);    
    // 在render之前触发    
    // 返回新的state    
    return {
        hasError: true,
    };
}
componentDidCatch(error, info) {
    // 统计页面的错误。发送请求发送到后台去
    console.log(error, info);
}
```

## 9. 组件通信方式总结

#### 组件间的关系：

- 父子组件
- 兄弟组件（非嵌套组件）
- 祖孙组件（跨级组件）

#### 几种通信方式：

	1.props：
	    (1).children props
	    (2).render props
	2.消息订阅-发布：
		pubs-sub、event等等
	3.集中式管理：
		redux、dva等等
	4.conText:
		生产者-消费者模式

#### 比较好的搭配方式：

	父子组件：props
	兄弟组件：消息订阅-发布、集中式管理
	祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(开发用的少，封装插件用的多)

761`
